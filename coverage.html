
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/animalet/sargantana-go/config/config.go (100.0%)</option>
				
				<option value="file1">github.com/animalet/sargantana-go/controller/auth.go (65.1%)</option>
				
				<option value="file2">github.com/animalet/sargantana-go/controller/load_balancer.go (85.9%)</option>
				
				<option value="file3">github.com/animalet/sargantana-go/controller/static.go (88.9%)</option>
				
				<option value="file4">github.com/animalet/sargantana-go/database/neo4j.go (0.0%)</option>
				
				<option value="file5">github.com/animalet/sargantana-go/database/redis.go (100.0%)</option>
				
				<option value="file6">github.com/animalet/sargantana-go/server/server.go (83.9%)</option>
				
				<option value="file7">github.com/animalet/sargantana-go/session/cookie_session.go (100.0%)</option>
				
				<option value="file8">github.com/animalet/sargantana-go/session/redis_session.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

type Config struct {
        address           string
        redisSessionStore string
        secretsDir        string
        debug             bool
        sessionName       string
}

func NewConfig(address, redisSessionStore, secretsDir string, debug bool, sessionName string) *Config <span class="cov10" title="5">{
        return &amp;Config{
                address:           address,
                redisSessionStore: redisSessionStore,
                secretsDir:        secretsDir,
                debug:             debug,
                sessionName:       sessionName,
        }
}</span>

func (c *Config) Address() string <span class="cov10" title="5">{
        return c.address
}</span>

func (c *Config) RedisSessionStore() string <span class="cov10" title="5">{
        return c.redisSessionStore
}</span>

func (c *Config) SecretsDir() string <span class="cov10" title="5">{
        return c.secretsDir
}</span>

func (c *Config) Debug() bool <span class="cov10" title="5">{
        return c.debug
}</span>

func (c *Config) SessionName() string <span class="cov10" title="5">{
        return c.sessionName
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "encoding/gob"
        "flag"
        "fmt"
        "log"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/animalet/sargantana-go/config"
        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "github.com/markbates/goth"
        "github.com/markbates/goth/gothic"
        "github.com/markbates/goth/providers/amazon"
        "github.com/markbates/goth/providers/apple"
        "github.com/markbates/goth/providers/auth0"
        "github.com/markbates/goth/providers/azuread"
        "github.com/markbates/goth/providers/battlenet"
        "github.com/markbates/goth/providers/bitbucket"
        "github.com/markbates/goth/providers/box"
        "github.com/markbates/goth/providers/dailymotion"
        "github.com/markbates/goth/providers/deezer"
        "github.com/markbates/goth/providers/digitalocean"
        "github.com/markbates/goth/providers/discord"
        "github.com/markbates/goth/providers/dropbox"
        "github.com/markbates/goth/providers/eveonline"
        "github.com/markbates/goth/providers/facebook"
        "github.com/markbates/goth/providers/fitbit"
        "github.com/markbates/goth/providers/gitea"
        "github.com/markbates/goth/providers/github"
        "github.com/markbates/goth/providers/gitlab"
        "github.com/markbates/goth/providers/google"
        "github.com/markbates/goth/providers/heroku"
        "github.com/markbates/goth/providers/instagram"
        "github.com/markbates/goth/providers/intercom"
        "github.com/markbates/goth/providers/kakao"
        "github.com/markbates/goth/providers/lastfm"
        "github.com/markbates/goth/providers/line"
        "github.com/markbates/goth/providers/linkedin"
        "github.com/markbates/goth/providers/mastodon"
        "github.com/markbates/goth/providers/meetup"
        "github.com/markbates/goth/providers/microsoftonline"
        "github.com/markbates/goth/providers/naver"
        "github.com/markbates/goth/providers/nextcloud"
        "github.com/markbates/goth/providers/okta"
        "github.com/markbates/goth/providers/onedrive"
        "github.com/markbates/goth/providers/patreon"
        "github.com/markbates/goth/providers/paypal"
        "github.com/markbates/goth/providers/salesforce"
        "github.com/markbates/goth/providers/seatalk"
        "github.com/markbates/goth/providers/shopify"
        "github.com/markbates/goth/providers/slack"
        "github.com/markbates/goth/providers/soundcloud"
        "github.com/markbates/goth/providers/spotify"
        "github.com/markbates/goth/providers/steam"
        "github.com/markbates/goth/providers/strava"
        "github.com/markbates/goth/providers/stripe"
        "github.com/markbates/goth/providers/tiktok"
        "github.com/markbates/goth/providers/twitch"
        "github.com/markbates/goth/providers/twitter"
        "github.com/markbates/goth/providers/twitterv2"
        "github.com/markbates/goth/providers/typetalk"
        "github.com/markbates/goth/providers/uber"
        "github.com/markbates/goth/providers/vk"
        "github.com/markbates/goth/providers/wecom"
        "github.com/markbates/goth/providers/wepay"
        "github.com/markbates/goth/providers/xero"
        "github.com/markbates/goth/providers/yahoo"
        "github.com/markbates/goth/providers/yammer"
        "github.com/markbates/goth/providers/yandex"
        "github.com/markbates/goth/providers/zoom"
)

type Auth struct {
        IController
        callbackAddress string
}

type UserObject struct {
        Id   string    `json:"id"`
        User goth.User `json:"user"`
}

func providers(callbackEndpoint string) <span class="cov6" title="5">{
        gob.Register(UserObject{})
        callbackURLTemplate := callbackEndpoint + "/auth/%s/callback"

        goth.UseProviders(
                // Use twitterv2 instead of twitter if you only have access to the Essential API Level
                twitterv2.New(os.Getenv("TWITTER_KEY"), os.Getenv("TWITTER_SECRET"), fmt.Sprintf(callbackURLTemplate, "twitterv2")),
                // If you'd like to use authenticate instead of authorize in TwitterV2 provider, use this instead.
                // twitterv2.NewAuthenticate(os.Getenv("TWITTER_KEY"), os.Getenv("TWITTER_SECRET"), fmt.Sprintf(callbackURLTemplate, "twitterv2")),

                twitter.New(os.Getenv("TWITTER_KEY"), os.Getenv("TWITTER_SECRET"), fmt.Sprintf(callbackURLTemplate, "twitter")),
                // If you'd like to use authenticate instead of authorize in Twitter provider, use this instead.
                // twitter.NewAuthenticate(os.Getenv("TWITTER_KEY"), os.Getenv("TWITTER_SECRET"), fmt.Sprintf(callbackURLTemplate, "twitter")),

                tiktok.New(os.Getenv("TIKTOK_KEY"), os.Getenv("TIKTOK_SECRET"), fmt.Sprintf(callbackURLTemplate, "tiktok")),
                facebook.New(os.Getenv("FACEBOOK_KEY"), os.Getenv("FACEBOOK_SECRET"), fmt.Sprintf(callbackURLTemplate, "facebook"), "email", "public_profile"),
                fitbit.New(os.Getenv("FITBIT_KEY"), os.Getenv("FITBIT_SECRET"), fmt.Sprintf(callbackURLTemplate, "fitbit")),
                google.New(os.Getenv("GOOGLE_KEY"), os.Getenv("GOOGLE_SECRET"), fmt.Sprintf(callbackURLTemplate, "google")),
                //gplus.New(os.Getenv("GPLUS_KEY"), os.Getenv("GPLUS_SECRET"), fmt.Sprintf(callbackURLTemplate, "gplus")),
                github.New(os.Getenv("GITHUB_KEY"), os.Getenv("GITHUB_SECRET"), fmt.Sprintf(callbackURLTemplate, "github"), "read:user", "user:email"),
                spotify.New(os.Getenv("SPOTIFY_KEY"), os.Getenv("SPOTIFY_SECRET"), fmt.Sprintf(callbackURLTemplate, "spotify")),
                linkedin.New(os.Getenv("LINKEDIN_KEY"), os.Getenv("LINKEDIN_SECRET"), fmt.Sprintf(callbackURLTemplate, "linkedin")),
                line.New(os.Getenv("LINE_KEY"), os.Getenv("LINE_SECRET"), fmt.Sprintf(callbackURLTemplate, "line"), "profile", "openid", "email"),
                lastfm.New(os.Getenv("LASTFM_KEY"), os.Getenv("LASTFM_SECRET"), fmt.Sprintf(callbackURLTemplate, "lastfm")),
                twitch.New(os.Getenv("TWITCH_KEY"), os.Getenv("TWITCH_SECRET"), fmt.Sprintf(callbackURLTemplate, "twitch")),
                dropbox.New(os.Getenv("DROPBOX_KEY"), os.Getenv("DROPBOX_SECRET"), fmt.Sprintf(callbackURLTemplate, "dropbox")),
                digitalocean.New(os.Getenv("DIGITALOCEAN_KEY"), os.Getenv("DIGITALOCEAN_SECRET"), fmt.Sprintf(callbackURLTemplate, "digitalocean"), "read"),
                bitbucket.New(os.Getenv("BITBUCKET_KEY"), os.Getenv("BITBUCKET_SECRET"), fmt.Sprintf(callbackURLTemplate, "bitbucket")),
                instagram.New(os.Getenv("INSTAGRAM_KEY"), os.Getenv("INSTAGRAM_SECRET"), fmt.Sprintf(callbackURLTemplate, "instagram")),
                intercom.New(os.Getenv("INTERCOM_KEY"), os.Getenv("INTERCOM_SECRET"), fmt.Sprintf(callbackURLTemplate, "intercom")),
                box.New(os.Getenv("BOX_KEY"), os.Getenv("BOX_SECRET"), fmt.Sprintf(callbackURLTemplate, "box")),
                salesforce.New(os.Getenv("SALESFORCE_KEY"), os.Getenv("SALESFORCE_SECRET"), fmt.Sprintf(callbackURLTemplate, "salesforce")),
                seatalk.New(os.Getenv("SEATALK_KEY"), os.Getenv("SEATALK_SECRET"), fmt.Sprintf(callbackURLTemplate, "seatalk")),
                amazon.New(os.Getenv("AMAZON_KEY"), os.Getenv("AMAZON_SECRET"), fmt.Sprintf(callbackURLTemplate, "amazon")),
                yammer.New(os.Getenv("YAMMER_KEY"), os.Getenv("YAMMER_SECRET"), fmt.Sprintf(callbackURLTemplate, "yammer")),
                onedrive.New(os.Getenv("ONEDRIVE_KEY"), os.Getenv("ONEDRIVE_SECRET"), fmt.Sprintf(callbackURLTemplate, "onedrive")),
                azuread.New(os.Getenv("AZUREAD_KEY"), os.Getenv("AZUREAD_SECRET"), fmt.Sprintf(callbackURLTemplate, "azuread"), nil),
                microsoftonline.New(os.Getenv("MICROSOFTONLINE_KEY"), os.Getenv("MICROSOFTONLINE_SECRET"), fmt.Sprintf(callbackURLTemplate, "microsoftonline")),
                battlenet.New(os.Getenv("BATTLENET_KEY"), os.Getenv("BATTLENET_SECRET"), fmt.Sprintf(callbackURLTemplate, "battlenet")),
                eveonline.New(os.Getenv("EVEONLINE_KEY"), os.Getenv("EVEONLINE_SECRET"), fmt.Sprintf(callbackURLTemplate, "eveonline")),
                kakao.New(os.Getenv("KAKAO_KEY"), os.Getenv("KAKAO_SECRET"), fmt.Sprintf(callbackURLTemplate, "kakao")),

                // Pointed https://localhost.com to http://localhost:3000/auth/yahoo/callback
                // Yahoo only accepts urls that starts with https
                yahoo.New(os.Getenv("YAHOO_KEY"), os.Getenv("YAHOO_SECRET"), "https://localhost.com"),
                typetalk.New(os.Getenv("TYPETALK_KEY"), os.Getenv("TYPETALK_SECRET"), fmt.Sprintf(callbackURLTemplate, "typetalk"), "my"),
                slack.New(os.Getenv("SLACK_KEY"), os.Getenv("SLACK_SECRET"), fmt.Sprintf(callbackURLTemplate, "slack")),
                stripe.New(os.Getenv("STRIPE_KEY"), os.Getenv("STRIPE_SECRET"), fmt.Sprintf(callbackURLTemplate, "stripe")),
                wepay.New(os.Getenv("WEPAY_KEY"), os.Getenv("WEPAY_SECRET"), fmt.Sprintf(callbackURLTemplate, "wepay"), "view_user"),
                // By default paypal production auth urls will be used, please set PAYPAL_ENV=sandbox as environment variable for testing
                // in sandbox environment
                paypal.New(os.Getenv("PAYPAL_KEY"), os.Getenv("PAYPAL_SECRET"), fmt.Sprintf(callbackURLTemplate, "paypal")),
                steam.New(os.Getenv("STEAM_KEY"), fmt.Sprintf(callbackURLTemplate, "steam")),
                heroku.New(os.Getenv("HEROKU_KEY"), os.Getenv("HEROKU_SECRET"), fmt.Sprintf(callbackURLTemplate, "heroku")),
                uber.New(os.Getenv("UBER_KEY"), os.Getenv("UBER_SECRET"), fmt.Sprintf(callbackURLTemplate, "uber")),
                soundcloud.New(os.Getenv("SOUNDCLOUD_KEY"), os.Getenv("SOUNDCLOUD_SECRET"), fmt.Sprintf(callbackURLTemplate, "soundcloud")),
                gitlab.New(os.Getenv("GITLAB_KEY"), os.Getenv("GITLAB_SECRET"), fmt.Sprintf(callbackURLTemplate, "gitlab")),
                dailymotion.New(os.Getenv("DAILYMOTION_KEY"), os.Getenv("DAILYMOTION_SECRET"), fmt.Sprintf(callbackURLTemplate, "dailymotion"), "email"),
                deezer.New(os.Getenv("DEEZER_KEY"), os.Getenv("DEEZER_SECRET"), fmt.Sprintf(callbackURLTemplate, "deezer"), "email"),
                discord.New(os.Getenv("DISCORD_KEY"), os.Getenv("DISCORD_SECRET"), fmt.Sprintf(callbackURLTemplate, "discord"), discord.ScopeIdentify, discord.ScopeEmail),
                meetup.New(os.Getenv("MEETUP_KEY"), os.Getenv("MEETUP_SECRET"), fmt.Sprintf(callbackURLTemplate, "meetup")),

                // Auth0 allocates domain per customer, a domain must be provided for auth0 to work
                auth0.New(os.Getenv("AUTH0_KEY"), os.Getenv("AUTH0_SECRET"), fmt.Sprintf(callbackURLTemplate, "auth0"), os.Getenv("AUTH0_DOMAIN")),
                xero.New(os.Getenv("XERO_KEY"), os.Getenv("XERO_SECRET"), fmt.Sprintf(callbackURLTemplate, "xero")),
                vk.New(os.Getenv("VK_KEY"), os.Getenv("VK_SECRET"), fmt.Sprintf(callbackURLTemplate, "vk")),
                naver.New(os.Getenv("NAVER_KEY"), os.Getenv("NAVER_SECRET"), fmt.Sprintf(callbackURLTemplate, "naver")),
                yandex.New(os.Getenv("YANDEX_KEY"), os.Getenv("YANDEX_SECRET"), fmt.Sprintf(callbackURLTemplate, "yandex")),
                nextcloud.NewCustomisedDNS(os.Getenv("NEXTCLOUD_KEY"), os.Getenv("NEXTCLOUD_SECRET"), fmt.Sprintf(callbackURLTemplate, "nextcloud"), os.Getenv("NEXTCLOUD_URL")),
                gitea.New(os.Getenv("GITEA_KEY"), os.Getenv("GITEA_SECRET"), fmt.Sprintf(callbackURLTemplate, "gitea")),
                shopify.New(os.Getenv("SHOPIFY_KEY"), os.Getenv("SHOPIFY_SECRET"), fmt.Sprintf(callbackURLTemplate, "shopify"), shopify.ScopeReadCustomers, shopify.ScopeReadOrders),
                apple.New(os.Getenv("APPLE_KEY"), os.Getenv("APPLE_SECRET"), fmt.Sprintf(callbackURLTemplate, "apple"), nil, apple.ScopeName, apple.ScopeEmail),
                strava.New(os.Getenv("STRAVA_KEY"), os.Getenv("STRAVA_SECRET"), fmt.Sprintf(callbackURLTemplate, "strava")),
                okta.New(os.Getenv("OKTA_ID"), os.Getenv("OKTA_SECRET"), os.Getenv("OKTA_ORG_URL"), fmt.Sprintf(callbackURLTemplate, "okta"), "openid", "profile", "email"),
                mastodon.New(os.Getenv("MASTODON_KEY"), os.Getenv("MASTODON_SECRET"), fmt.Sprintf(callbackURLTemplate, "mastodon"), "read:accounts"),
                wecom.New(os.Getenv("WECOM_CORP_ID"), os.Getenv("WECOM_SECRET"), os.Getenv("WECOM_AGENT_ID"), fmt.Sprintf(callbackURLTemplate, "wecom")),
                zoom.New(os.Getenv("ZOOM_KEY"), os.Getenv("ZOOM_SECRET"), fmt.Sprintf(callbackURLTemplate, "zoom"), "read:user"),
                patreon.New(os.Getenv("PATREON_KEY"), os.Getenv("PATREON_SECRET"), fmt.Sprintf(callbackURLTemplate, "patreon")),
        )
}</span>

func NewAuth(callbackEndpoint string) *Auth <span class="cov10" title="12">{
        return &amp;Auth{callbackAddress: callbackEndpoint}
}</span>

func NewAuthFromFlags(flagSet *flag.FlagSet) func() IController <span class="cov3" title="2">{
        callback := flagSet.String("callback", "", "Callback endpoint for authentication, in case you are behind a reverse proxy or load balancer. If not set, it will default to http://&lt;host&gt;:&lt;port&gt;")
        return func() IController </span><span class="cov3" title="2">{ return NewAuth(*callback) }</span>
}

func LoginFunc(c *gin.Context) <span class="cov6" title="4">{
        userSession := sessions.Default(c)
        userObject := userSession.Get("user")
        if userObject == nil </span><span class="cov3" title="2">{
                c.AbortWithStatus(http.StatusForbidden)
                return
        }</span>

        <span class="cov3" title="2">if time.Now().After(userObject.(UserObject).User.ExpiresAt) </span><span class="cov1" title="1">{
                userSession.Clear()
                if err := userSession.Save(); err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusInternalServerError)
                        _ = c.Error(gin.Error{
                                Err:  err,
                                Type: gin.ErrorTypePrivate,
                        })
                }</span> else<span class="cov1" title="1"> {
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>
                <span class="cov1" title="1">return</span>
        }

        <span class="cov1" title="1">c.Next()</span>
}

func (a *Auth) Bind(server *gin.Engine, config config.Config, loginMiddleware gin.HandlerFunc) <span class="cov6" title="5">{
        if a.callbackAddress == "" </span><span class="cov3" title="2">{
                address := config.Address()
                // Add http:// if not present
                if !strings.Contains(address, "://") </span><span class="cov3" title="2">{
                        address = "http://" + address
                }</span>
                <span class="cov3" title="2">u, err := url.Parse(address)
                if err != nil </span><span class="cov0" title="0">{
                        log.Panicf("Failed to parse auth callback address %q: %v", address, err)
                }</span>
                <span class="cov3" title="2">if u.Hostname() == "0.0.0.0" </span><span class="cov1" title="1">{
                        log.Println("Auth callback endpoint is set to 0.0.0.0, changing it to localhost")
                        a.callbackAddress = u.Scheme + "://localhost" + ":" + u.Port()
                }</span>
                <span class="cov3" title="2">a.callbackAddress = u.Scheme + "://" + u.Hostname() + ":" + u.Port()</span>
        }

        <span class="cov6" title="5">log.Printf("Callback endpoint: %q\n", a.callbackAddress)
        providers(a.callbackAddress)

        server.Group("/auth").
                Use(func(c *gin.Context) </span><span class="cov1" title="1">{
                        // Hack to make gothic work with gin
                        q := c.Request.URL.Query()
                        q.Add("provider", c.Param("provider"))
                        c.Request.URL.RawQuery = q.Encode()
                        c.Next()
                }</span>).
                GET("/:provider", a.login).
                GET("/:provider/callback", a.callback).
                GET("/:provider/logout", a.logout).
                GET("/user", loginMiddleware, func(c *gin.Context) <span class="cov0" title="0">{
                        c.JSON(http.StatusOK, sessions.Default(c).Get("user").(UserObject).Id)
                }</span>)
}

func (a *Auth) Close() error <span class="cov1" title="1">{
        return nil
}</span>

func (a *Auth) success(c *gin.Context, user goth.User) <span class="cov0" title="0">{
        session := sessions.Default(c)
        session.Set("user", a.userFactory(user))
        a.saveSession(c, session)
}</span>

func (a *Auth) login(c *gin.Context) <span class="cov0" title="0">{
        if user, err := gothic.CompleteUserAuth(c.Writer, c.Request); err != nil </span><span class="cov0" title="0">{
                gothic.BeginAuthHandler(c.Writer, c.Request)
        }</span> else<span class="cov0" title="0"> {
                a.success(c, user)
        }</span>
}

func (a *Auth) callback(c *gin.Context) <span class="cov0" title="0">{
        if user, err := gothic.CompleteUserAuth(c.Writer, c.Request); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusForbidden, err)
        }</span> else<span class="cov0" title="0"> {
                a.success(c, user)
        }</span>
}

func (a *Auth) logout(c *gin.Context) <span class="cov0" title="0">{
        err := gothic.Logout(c.Writer, c.Request)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to log out: %v", err)
        }</span>
        <span class="cov0" title="0">session := sessions.Default(c)
        session.Clear()
        a.saveSession(c, session)</span>
}

func (a *Auth) saveSession(c *gin.Context, session sessions.Session) <span class="cov0" title="0">{
        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
        }</span> else<span class="cov0" title="0"> {
                c.Redirect(http.StatusFound, "/")
        }</span>
}

func (a *Auth) userFactory(user goth.User) *UserObject <span class="cov3" title="2">{
        var id string
        if user.Email == "" </span><span class="cov1" title="1">{
                id = user.UserID + "@" + user.Provider
        }</span> else<span class="cov1" title="1"> {
                id = user.Email
        }</span>
        <span class="cov3" title="2">return &amp;UserObject{
                Id:   id,
                User: user,
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "flag"
        "io"
        "log"
        "net/http"
        "net/url"
        "strings"
        "sync"

        "github.com/animalet/sargantana-go/config"
        "github.com/gin-gonic/gin"
)

type LoadBalancer struct {
        IController
        endpoints     []url.URL
        endpointIndex int
        mu            sync.Mutex
        httpClient    *http.Client
        path          string
        auth          bool
}

func NewLoadBalancer(endpoints []url.URL, path string, auth bool) *LoadBalancer <span class="cov9" title="15">{
        if len(endpoints) == 0 </span><span class="cov5" title="5">{
                log.Printf("No endpoints provided for load balancing")
        }</span> else<span class="cov7" title="10"> {
                log.Printf("Load balanced endpoints:")
                for _, endpoint := range endpoints </span><span class="cov9" title="15">{
                        log.Printf("%v", endpoint.String())
                }</span>
        }

        <span class="cov9" title="15">log.Printf("Load balancing path: %q\n", path)
        log.Printf("Load balancing authentication: %t\n", auth)
        log.Printf("Load balancer endpoints: %v\n", endpoints)

        httpClient := &amp;http.Client{
                Transport: &amp;http.Transport{
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 10,
                },
        }

        return &amp;LoadBalancer{
                endpoints:  endpoints,
                httpClient: httpClient,
                path:       path,
                auth:       auth,
        }</span>
}

func NewLoadBalancerFromFlags(flagSet *flag.FlagSet) func() IController <span class="cov3" title="2">{
        lbPath := flagSet.String("lbpath", "lb", "Path to use for load balancing")
        lbAuth := flagSet.Bool("lbauth", false, "Use authentication for load balancing")

        lbEndpoints := make([]url.URL, 0)
        flagSet.Func("lb", "Path to use for load balancing", func(s string) error </span><span class="cov3" title="2">{
                u, err := url.Parse(s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="2">lbEndpoints = append(lbEndpoints, *u)
                return nil</span>
        })
        <span class="cov3" title="2">return func() IController </span><span class="cov3" title="2">{ return NewLoadBalancer(lbEndpoints, *lbPath, *lbAuth) }</span>
}

func (l *LoadBalancer) Bind(server *gin.Engine, _ config.Config, loginMiddleware gin.HandlerFunc) <span class="cov5" title="4">{
        if len(l.endpoints) == 0 </span><span class="cov3" title="2">{
                log.Printf("Load balancer not loaded")
                return
        }</span>

        <span class="cov3" title="2">if l.auth </span><span class="cov1" title="1">{
                server.Any(l.path, loginMiddleware, l.forward)
        }</span> else<span class="cov1" title="1"> {
                server.Any(l.path, l.forward)
        }</span>
}

func (l *LoadBalancer) Close() error <span class="cov1" title="1">{
        return nil
}</span>

func (l *LoadBalancer) nextEndpoint() url.URL <span class="cov10" title="21">{
        l.mu.Lock()
        defer func() </span><span class="cov10" title="21">{
                l.endpointIndex = (l.endpointIndex + 1) % len(l.endpoints)
                l.mu.Unlock()
        }</span>()
        <span class="cov10" title="21">return l.endpoints[l.endpointIndex]</span>
}

var allowedMethods = map[string]bool{"GET": true, "POST": true, "PUT": true, "DELETE": true, "PATCH": true, "HEAD": true, "OPTIONS": true}

func (l *LoadBalancer) forward(c *gin.Context) <span class="cov6" title="6">{
        // Only allow safe HTTP methods
        if !allowedMethods[c.Request.Method] </span><span class="cov1" title="1">{
                c.AbortWithStatus(http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov5" title="5">endpoint := l.nextEndpoint()
        // Build the target URL using only path and raw query
        targetUrl := url.URL{
                Scheme:   endpoint.Scheme,
                Host:     endpoint.Host,
                Path:     c.Request.URL.Path,
                RawQuery: c.Request.URL.RawQuery,
        }

        // Create the new request
        request, err := http.NewRequest(c.Request.Method, targetUrl.String(), c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
                return
        }</span>

        // Filter headers to avoid leaking sensitive data
        <span class="cov5" title="5">for k, v := range c.Request.Header </span><span class="cov1" title="1">{
                // Skip Host, X-Forwarded-For, Authorization, Cookie, etc.
                if strings.EqualFold(k, "Host") || strings.HasPrefix(strings.ToLower(k), "x-forwarded-") || strings.EqualFold(k, "Authorization") || strings.EqualFold(k, "Cookie") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">for _, vv := range v </span><span class="cov1" title="1">{
                        request.Header.Add(k, vv)
                }</span>
        }

        <span class="cov5" title="5">request.Header.Set("X-Forwarded-For", c.ClientIP())

        response, err := l.httpClient.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusBadGateway, err)
                return
        }</span>
        <span class="cov5" title="5">defer func() </span><span class="cov5" title="5">{
                err = response.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing response body: %v", err)
                }</span>
        }()

        <span class="cov5" title="5">c.Status(response.StatusCode)
        for k, v := range response.Header </span><span class="cov9" title="15">{
                if strings.EqualFold(k, "Set-Cookie") </span><span class="cov0" title="0">{
                        continue</span> // avoid leaking backend cookies
                }
                <span class="cov9" title="15">for _, vv := range v </span><span class="cov9" title="15">{
                        c.Writer.Header().Add(k, vv)
                }</span>
        }
        // Copy response body
        <span class="cov5" title="5">if _, err := io.Copy(c.Writer, response.Body); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "flag"
        "io/fs"
        "log"
        "os"
        "path/filepath"

        "github.com/animalet/sargantana-go/config"
        "github.com/gin-gonic/gin"
)

type Static struct {
        IController
        staticsDir       string
        htmlTemplatesDir string
}

func NewStatic(staticsDir, htmlTemplatesDir string) *Static <span class="cov10" title="11">{
        log.Printf("Statics directory: %q\n", staticsDir)
        log.Printf("Templates directory: %q\n", htmlTemplatesDir)

        return &amp;Static{
                staticsDir:       staticsDir,
                htmlTemplatesDir: htmlTemplatesDir,
        }
}</span>

func NewStaticFromFlags(flagSet *flag.FlagSet) func() IController <span class="cov3" title="2">{
        frontend := flagSet.String("frontend", "./frontend", "Path to the frontend static content directory")
        templates := flagSet.String("templates", "./templates", "Path to the templates directory")
        return func() IController </span><span class="cov3" title="2">{ return NewStatic(*frontend, *templates) }</span>
}

func (s *Static) Bind(server *gin.Engine, _ config.Config, _ gin.HandlerFunc) <span class="cov7" title="5">{
        server.Static("/static", s.staticsDir)
        server.GET("/", func(c *gin.Context) </span><span class="cov3" title="2">{
                c.Header("Content-Type", "text/html")
                c.File(s.staticsDir + "/index.html")
        }</span>)

        <span class="cov7" title="5">if stat, err := os.Stat(s.htmlTemplatesDir); stat != nil &amp;&amp; stat.IsDir() </span><span class="cov3" title="2">{
                // check if dir is empty
                var found bool
                err = filepath.WalkDir(s.htmlTemplatesDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov5" title="3">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov5" title="3">if !d.IsDir() </span><span class="cov1" title="1">{
                                found = true
                        }</span>
                        <span class="cov5" title="3">return nil</span>
                })

                <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error walking through templates directory: %v", err)
                        return
                }</span>

                <span class="cov3" title="2">if found </span><span class="cov1" title="1">{
                        server.LoadHTMLGlob(s.htmlTemplatesDir + "/**")
                }</span> else<span class="cov1" title="1"> {
                        log.Printf("Templates directory present but no files found, skipping templates.")
                }</span>
        } else<span class="cov5" title="3"> {
                log.Printf("Templates directory not present: %v", err)
        }</span>
}

func (s *Static) Close() error <span class="cov1" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "context"
        "log"
        "time"

        "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

type Neo4jOptions struct {
        Uri      string
        Username string
        Password string
        Realm    string
}

func NewNeo4jDriver(options *Neo4jOptions) (neo4j.DriverWithContext, func()) <span class="cov0" title="0">{
        auth := neo4j.BasicAuth(options.Username, options.Password, options.Realm)
        driver, err := neo4j.NewDriverWithContext(options.Uri, auth)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create Neo4j driver: %v", err)
        }</span>

        <span class="cov0" title="0">timeout, cancelFunc := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancelFunc()

        session := driver.NewSession(timeout, neo4j.SessionConfig{DatabaseName: "neo4j"})
        defer func() </span><span class="cov0" title="0">{
                err := session.Close(timeout)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close Neo4j session: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">err = driver.VerifyConnectivity(timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to Neo4j: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Connected to Neo4j at %s", options.Uri)

        closeFunc := func() </span><span class="cov0" title="0">{
                err := driver.Close(timeout)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to close Neo4j driver: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return driver, closeFunc</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "time"

        "github.com/gomodule/redigo/redis"
)

func NewRedisPool(address string) *redis.Pool <span class="cov10" title="6">{
        return &amp;redis.Pool{
                TestOnBorrow: func(c redis.Conn, t time.Time) error </span><span class="cov6" title="3">{
                        if time.Since(t) &lt; time.Minute </span><span class="cov1" title="1">{
                                return nil
                        }</span>
                        <span class="cov4" title="2">_, err := c.Do("PING")
                        return err</span>
                },
                MaxIdle:     10,
                IdleTimeout: 240 * time.Second,
                Dial:        func() (redis.Conn, error) <span class="cov4" title="2">{ return redis.Dial("tcp", address) }</span>,
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package server

import (
        "bytes"
        "context"
        "errors"
        "flag"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/animalet/sargantana-go/config"
        "github.com/animalet/sargantana-go/controller"
        "github.com/animalet/sargantana-go/database"
        "github.com/animalet/sargantana-go/session"
        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

type Server struct {
        config          *config.Config
        httpServer      *http.Server
        shutdownHooks   []func() error
        shutdownChannel chan os.Signal
}

func NewServer(host string, port int, redis, secretsDir string, debug bool, sessionName string) *Server <span class="cov9" title="12">{
        c := config.NewConfig(
                address(host, port),
                redis,
                secretsDir,
                debug,
                sessionName,
        )
        return &amp;Server{config: c}
}</span>

func NewServerFromFlags(flagInitializers ...func(flagSet *flag.FlagSet) func() controller.IController) (*Server, []controller.IController) <span class="cov3" title="2">{
        flagSet := flag.NewFlagSet(os.Args[0], flag.ExitOnError)
        debug := flagSet.Bool("debug", false, "Enable debug mode")
        secretsDir := flagSet.String("secrets", "", "Path to the secrets directory")
        host := flagSet.String("host", "localhost", "Host to listen on")
        port := flagSet.Int("port", 8080, "port to listen on")
        redis := flagSet.String("redis", "", "Use the specified Redis address as a session store. It expects &lt;host&gt;[:&lt;port&gt;] format and only TCP is currently supported. Defaults to cookie based session storage")
        sessionName := flagSet.String("cookiename", "sargantana-go", "Session cookie name. Be aware that this name will be used regardless of the session storage type (cookies or Redis)")

        var constructors []func() controller.IController
        for _, init := range flagInitializers </span><span class="cov3" title="2">{
                constructors = append(constructors, init(flagSet))
        }</span>

        <span class="cov3" title="2">var controllers []controller.IController
        _ = flagSet.Parse(os.Args[1:])
        for _, c := range constructors </span><span class="cov3" title="2">{
                controllers = append(controllers, c())
        }</span>

        <span class="cov3" title="2">return NewServer(
                *host, *port,
                *redis,
                *secretsDir,
                *debug,
                *sessionName), controllers</span>
}

func address(host string, port int) string <span class="cov10" title="15">{
        return host + ":" + strconv.Itoa(port)
}</span>

func (s *Server) StartAndWaitForSignal(appControllers ...controller.IController) error <span class="cov1" title="1">{
        err := s.Start(appControllers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return s.waitForSignal()</span>
}

func (s *Server) Start(appControllers ...controller.IController) error <span class="cov7" title="7">{
        if s.config.Debug() </span><span class="cov4" title="3">{
                log.Printf("Debug mode is enabled\n")
                log.Printf("Secrets directory: %q\n", s.config.SecretsDir())
                log.Printf("Listen address: %q\n", s.config.Address())
                if s.config.RedisSessionStore() == "" </span><span class="cov4" title="3">{
                        log.Printf("Use cookies for session storage\n")
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Use Redis for session storage: %s\n", s.config.RedisSessionStore())
                }</span>
                <span class="cov4" title="3">log.Printf("Session cookie name: %q\n", s.config.SessionName())</span>
        } else<span class="cov5" title="4"> {
                gin.SetMode(gin.ReleaseMode)
        }</span>

        <span class="cov7" title="7">if err := s.bootstrap(appControllers...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="7">return nil</span>
}

func (s *Server) loadSecrets() error <span class="cov8" title="11">{
        if s.config.SecretsDir() == "" </span><span class="cov7" title="7">{
                log.Println("No secrets directory configured, skipping secrets loading")
                return nil
        }</span>

        <span class="cov5" title="4">files, err := os.ReadDir(s.config.SecretsDir())
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error reading secrets directory %s: %v", s.config.SecretsDir(), err)
        }</span>
        <span class="cov4" title="3">count := 0
        for _, file := range files </span><span class="cov1" title="1">{
                if file.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">name := file.Name()
                content, err := os.ReadFile(filepath.Join(s.config.SecretsDir(), name))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error reading secret file %s: %v", name, err)
                }</span>
                <span class="cov1" title="1">err = os.Setenv(strings.ToUpper(name), strings.TrimSpace(string(content)))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error setting environment variable %s: %v", strings.ToUpper(name), err)
                }</span> else<span class="cov1" title="1"> {
                        count += 1
                        if s.config.Debug() </span><span class="cov0" title="0">{
                                log.Printf("Set environment variable from secret %s\n", strings.ToUpper(name))
                        }</span>
                }
        }
        <span class="cov4" title="3">if s.config.Debug() </span><span class="cov1" title="1">{
                log.Printf("Loaded %d secrets from %s\n", count, s.config.SecretsDir())
        }</span>

        <span class="cov4" title="3">return nil</span>
}

func (s *Server) bootstrap(appControllers ...controller.IController) error <span class="cov7" title="8">{
        err := s.loadSecrets()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="8">engine := gin.New()
        isReleaseMode := gin.Mode() == gin.ReleaseMode
        var sessionStore sessions.Store
        sessionSecret := []byte(os.Getenv("SESSION_SECRET"))
        if s.config.RedisSessionStore() == "" </span><span class="cov7" title="7">{
                log.Println("Using cookies for session storage")
                sessionStore = session.NewCookieStore(isReleaseMode, sessionSecret)
        }</span> else<span class="cov1" title="1"> {
                log.Println("Using Redis for session storage")
                pool := database.NewRedisPool(s.config.RedisSessionStore())
                s.addShutdownHook(func() error </span><span class="cov1" title="1">{ return pool.Close() }</span>)
                <span class="cov1" title="1">sessionStore = session.NewRedisSessionStore(isReleaseMode, sessionSecret, pool)</span>
        }

        <span class="cov7" title="8">if isReleaseMode </span><span class="cov6" title="5">{
                log.Println("Running in release mode")
                err := engine.SetTrustedProxies(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov4" title="3"> {
                engine.Use(ginBodyLogMiddleware)
        }</span>
        <span class="cov7" title="8">engine.Use(gin.Logger(), gin.Recovery())
        engine.Use(sessions.Sessions(s.config.SessionName(), sessionStore))
        for _, c := range appControllers </span><span class="cov8" title="10">{
                c.Bind(engine, *s.config, controller.LoginFunc)
                s.addShutdownHook(c.Close)
        }</span>

        <span class="cov7" title="8">s.httpServer = &amp;http.Server{
                Addr:    s.config.Address(),
                Handler: engine,
        }

        log.Println("Starting server on " + s.config.Address())
        s.listenAndServe()
        return nil</span>
}

func (s *Server) waitForSignal() error <span class="cov1" title="1">{
        s.shutdownChannel = make(chan os.Signal, 1)
        // kill (no params) by default sends syscall.SIGTERM
        // kill -2 is syscall.SIGINT
        // kill -9 is syscall.SIGKILL but can't be caught, so don't need to add it
        signal.Notify(s.shutdownChannel, syscall.SIGINT, syscall.SIGTERM)
        log.Printf("Shutdown signal received (%s)\n", &lt;-s.shutdownChannel)
        return s.Shutdown()
}</span>

func (s *Server) listenAndServe() <span class="cov7" title="8">{
        go func() </span><span class="cov7" title="8">{
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatalf("Listen error: %s", err)
                }</span>
        }()
}

func (s *Server) addShutdownHook(f func() error) <span class="cov8" title="11">{
        s.shutdownHooks = append(s.shutdownHooks, f)
}</span>

func (s *Server) Shutdown() error <span class="cov7" title="8">{
        log.Println("Shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("forced shutdown: %s", err)
        }</span>

        // Free up resources used by controllers
        <span class="cov7" title="8">log.Println("Executing shutdown hooks...")
        for _, hook := range s.shutdownHooks </span><span class="cov8" title="11">{
                if err := hook(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error during shutdown hook: %s", err)
                }</span>
        }

        <span class="cov7" title="8">log.Println("Server exited gracefully")
        return nil</span>
}

type bodyLogWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w bodyLogWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

func ginBodyLogMiddleware(c *gin.Context) <span class="cov0" title="0">{
        blw := &amp;bodyLogWriter{body: bytes.NewBufferString(""), ResponseWriter: c.Writer}
        c.Writer = blw
        c.Next()
        log.Printf("Response body: %s", blw.body.String())
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package session

import (
        "net/http"

        "github.com/gin-contrib/sessions"
        "github.com/gin-contrib/sessions/cookie"
        "github.com/markbates/goth/gothic"
)

func NewCookieStore(isReleaseMode bool, secret []byte) sessions.Store <span class="cov10" title="6">{
        store := cookie.NewStore(secret)

        store.Options(sessions.Options{
                Path:     "/",
                MaxAge:   86400, // 24 hours
                Secure:   isReleaseMode,
                HttpOnly: true,
                SameSite: http.SameSiteLaxMode,
        })

        gothic.Store = store
        return store
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package session

import (
        "log"
        "net/http"

        "github.com/gin-contrib/sessions"
        redissessions "github.com/gin-contrib/sessions/redis"
        "github.com/gomodule/redigo/redis"
        "github.com/markbates/goth/gothic"
)

func NewRedisSessionStore(isReleaseMode bool, secret []byte, pool *redis.Pool) sessions.Store <span class="cov10" title="2">{
        store, err := redissessions.NewStoreWithPool(pool, secret)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create session store: %v", err)
        }</span>

        <span class="cov10" title="2">rediStore, err := redissessions.GetRedisStore(store)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get redis store: %v", err)
        }</span>

        <span class="cov10" title="2">rediStore.Options.Path = "/"
        rediStore.Options.MaxAge = 86400 // 24 hours
        rediStore.Options.Secure = isReleaseMode
        rediStore.Options.HttpOnly = true
        rediStore.Options.SameSite = http.SameSiteLaxMode

        gothic.Store = rediStore
        return store</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
